// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: conf.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Bootstrap with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Bootstrap) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Bootstrap with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BootstrapMultiError, or nil
// if none found.
func (m *Bootstrap) ValidateAll() error {
	return m.validate(true)
}

func (m *Bootstrap) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetServer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BootstrapValidationError{
					field:  "Server",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BootstrapValidationError{
					field:  "Server",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetServer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BootstrapValidationError{
				field:  "Server",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BootstrapValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BootstrapValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BootstrapValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLog()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BootstrapValidationError{
					field:  "Log",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BootstrapValidationError{
					field:  "Log",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLog()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BootstrapValidationError{
				field:  "Log",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BootstrapMultiError(errors)
	}

	return nil
}

// BootstrapMultiError is an error wrapping multiple validation errors returned
// by Bootstrap.ValidateAll() if the designated constraints aren't met.
type BootstrapMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BootstrapMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BootstrapMultiError) AllErrors() []error { return m }

// BootstrapValidationError is the validation error returned by
// Bootstrap.Validate if the designated constraints aren't met.
type BootstrapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BootstrapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BootstrapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BootstrapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BootstrapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BootstrapValidationError) ErrorName() string { return "BootstrapValidationError" }

// Error satisfies the builtin error interface
func (e BootstrapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBootstrap.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BootstrapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BootstrapValidationError{}

// Validate checks the field values on Server with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Server) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Server with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ServerMultiError, or nil if none found.
func (m *Server) ValidateAll() error {
	return m.validate(true)
}

func (m *Server) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGateway()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServerValidationError{
					field:  "Gateway",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServerValidationError{
					field:  "Gateway",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGateway()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServerValidationError{
				field:  "Gateway",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLogic()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServerValidationError{
					field:  "Logic",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServerValidationError{
					field:  "Logic",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogic()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServerValidationError{
				field:  "Logic",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMsg()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServerValidationError{
					field:  "Msg",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServerValidationError{
					field:  "Msg",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMsg()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServerValidationError{
				field:  "Msg",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPush()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServerValidationError{
					field:  "Push",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServerValidationError{
					field:  "Push",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPush()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServerValidationError{
				field:  "Push",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ServerMultiError(errors)
	}

	return nil
}

// ServerMultiError is an error wrapping multiple validation errors returned by
// Server.ValidateAll() if the designated constraints aren't met.
type ServerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerMultiError) AllErrors() []error { return m }

// ServerValidationError is the validation error returned by Server.Validate if
// the designated constraints aren't met.
type ServerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerValidationError) ErrorName() string { return "ServerValidationError" }

// Error satisfies the builtin error interface
func (e ServerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerValidationError{}

// Validate checks the field values on GateWayConf with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GateWayConf) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GateWayConf with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GateWayConfMultiError, or
// nil if none found.
func (m *GateWayConf) ValidateAll() error {
	return m.validate(true)
}

func (m *GateWayConf) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetHttp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GateWayConfValidationError{
					field:  "Http",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GateWayConfValidationError{
					field:  "Http",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHttp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GateWayConfValidationError{
				field:  "Http",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GateWayConfValidationError{
					field:  "Ws",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GateWayConfValidationError{
					field:  "Ws",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GateWayConfValidationError{
				field:  "Ws",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGrpc()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GateWayConfValidationError{
					field:  "Grpc",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GateWayConfValidationError{
					field:  "Grpc",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGrpc()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GateWayConfValidationError{
				field:  "Grpc",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GateWayConfMultiError(errors)
	}

	return nil
}

// GateWayConfMultiError is an error wrapping multiple validation errors
// returned by GateWayConf.ValidateAll() if the designated constraints aren't met.
type GateWayConfMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GateWayConfMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GateWayConfMultiError) AllErrors() []error { return m }

// GateWayConfValidationError is the validation error returned by
// GateWayConf.Validate if the designated constraints aren't met.
type GateWayConfValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GateWayConfValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GateWayConfValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GateWayConfValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GateWayConfValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GateWayConfValidationError) ErrorName() string { return "GateWayConfValidationError" }

// Error satisfies the builtin error interface
func (e GateWayConfValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGateWayConf.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GateWayConfValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GateWayConfValidationError{}

// Validate checks the field values on LogicConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LogicConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogicConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LogicConfigMultiError, or
// nil if none found.
func (m *LogicConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *LogicConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGrpc()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogicConfigValidationError{
					field:  "Grpc",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogicConfigValidationError{
					field:  "Grpc",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGrpc()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogicConfigValidationError{
				field:  "Grpc",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LogicConfigMultiError(errors)
	}

	return nil
}

// LogicConfigMultiError is an error wrapping multiple validation errors
// returned by LogicConfig.ValidateAll() if the designated constraints aren't met.
type LogicConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogicConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogicConfigMultiError) AllErrors() []error { return m }

// LogicConfigValidationError is the validation error returned by
// LogicConfig.Validate if the designated constraints aren't met.
type LogicConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogicConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogicConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogicConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogicConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogicConfigValidationError) ErrorName() string { return "LogicConfigValidationError" }

// Error satisfies the builtin error interface
func (e LogicConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogicConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogicConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogicConfigValidationError{}

// Validate checks the field values on MsgConfig with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MsgConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MsgConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MsgConfigMultiError, or nil
// if none found.
func (m *MsgConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *MsgConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGrpc()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MsgConfigValidationError{
					field:  "Grpc",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MsgConfigValidationError{
					field:  "Grpc",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGrpc()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MsgConfigValidationError{
				field:  "Grpc",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MsgConfigMultiError(errors)
	}

	return nil
}

// MsgConfigMultiError is an error wrapping multiple validation errors returned
// by MsgConfig.ValidateAll() if the designated constraints aren't met.
type MsgConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MsgConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MsgConfigMultiError) AllErrors() []error { return m }

// MsgConfigValidationError is the validation error returned by
// MsgConfig.Validate if the designated constraints aren't met.
type MsgConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MsgConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MsgConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MsgConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MsgConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MsgConfigValidationError) ErrorName() string { return "MsgConfigValidationError" }

// Error satisfies the builtin error interface
func (e MsgConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMsgConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MsgConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MsgConfigValidationError{}

// Validate checks the field values on PushConfig with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PushConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PushConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PushConfigMultiError, or
// nil if none found.
func (m *PushConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *PushConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGrpc()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PushConfigValidationError{
					field:  "Grpc",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PushConfigValidationError{
					field:  "Grpc",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGrpc()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PushConfigValidationError{
				field:  "Grpc",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PushConfigMultiError(errors)
	}

	return nil
}

// PushConfigMultiError is an error wrapping multiple validation errors
// returned by PushConfig.ValidateAll() if the designated constraints aren't met.
type PushConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PushConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PushConfigMultiError) AllErrors() []error { return m }

// PushConfigValidationError is the validation error returned by
// PushConfig.Validate if the designated constraints aren't met.
type PushConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PushConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PushConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PushConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PushConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PushConfigValidationError) ErrorName() string { return "PushConfigValidationError" }

// Error satisfies the builtin error interface
func (e PushConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPushConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PushConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PushConfigValidationError{}

// Validate checks the field values on HTTP with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *HTTP) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HTTP with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in HTTPMultiError, or nil if none found.
func (m *HTTP) ValidateAll() error {
	return m.validate(true)
}

func (m *HTTP) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Network

	// no validation rules for Addr

	if all {
		switch v := interface{}(m.GetTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HTTPValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HTTPValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HTTPValidationError{
				field:  "Timeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return HTTPMultiError(errors)
	}

	return nil
}

// HTTPMultiError is an error wrapping multiple validation errors returned by
// HTTP.ValidateAll() if the designated constraints aren't met.
type HTTPMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HTTPMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HTTPMultiError) AllErrors() []error { return m }

// HTTPValidationError is the validation error returned by HTTP.Validate if the
// designated constraints aren't met.
type HTTPValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HTTPValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HTTPValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HTTPValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HTTPValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HTTPValidationError) ErrorName() string { return "HTTPValidationError" }

// Error satisfies the builtin error interface
func (e HTTPValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHTTP.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HTTPValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HTTPValidationError{}

// Validate checks the field values on GRPC with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *GRPC) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GRPC with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in GRPCMultiError, or nil if none found.
func (m *GRPC) ValidateAll() error {
	return m.validate(true)
}

func (m *GRPC) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Network

	// no validation rules for Addr

	if all {
		switch v := interface{}(m.GetTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GRPCValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GRPCValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GRPCValidationError{
				field:  "Timeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GRPCMultiError(errors)
	}

	return nil
}

// GRPCMultiError is an error wrapping multiple validation errors returned by
// GRPC.ValidateAll() if the designated constraints aren't met.
type GRPCMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GRPCMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GRPCMultiError) AllErrors() []error { return m }

// GRPCValidationError is the validation error returned by GRPC.Validate if the
// designated constraints aren't met.
type GRPCValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GRPCValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GRPCValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GRPCValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GRPCValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GRPCValidationError) ErrorName() string { return "GRPCValidationError" }

// Error satisfies the builtin error interface
func (e GRPCValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGRPC.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GRPCValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GRPCValidationError{}

// Validate checks the field values on Ws with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Ws) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Ws with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in WsMultiError, or nil if none found.
func (m *Ws) ValidateAll() error {
	return m.validate(true)
}

func (m *Ws) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReadBufferSize

	// no validation rules for WriteBufferSize

	// no validation rules for HandshakeTimeout

	if len(errors) > 0 {
		return WsMultiError(errors)
	}

	return nil
}

// WsMultiError is an error wrapping multiple validation errors returned by
// Ws.ValidateAll() if the designated constraints aren't met.
type WsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WsMultiError) AllErrors() []error { return m }

// WsValidationError is the validation error returned by Ws.Validate if the
// designated constraints aren't met.
type WsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WsValidationError) ErrorName() string { return "WsValidationError" }

// Error satisfies the builtin error interface
func (e WsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WsValidationError{}

// Validate checks the field values on Data with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Data with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DataMultiError, or nil if none found.
func (m *Data) ValidateAll() error {
	return m.validate(true)
}

func (m *Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDatabase()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DataValidationError{
					field:  "Database",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DataValidationError{
					field:  "Database",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatabase()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DataValidationError{
				field:  "Database",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRedis()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DataValidationError{
					field:  "Redis",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DataValidationError{
					field:  "Redis",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRedis()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DataValidationError{
				field:  "Redis",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEtcd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DataValidationError{
					field:  "Etcd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DataValidationError{
					field:  "Etcd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEtcd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DataValidationError{
				field:  "Etcd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRabbitmq()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DataValidationError{
					field:  "Rabbitmq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DataValidationError{
					field:  "Rabbitmq",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRabbitmq()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DataValidationError{
				field:  "Rabbitmq",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DataMultiError(errors)
	}

	return nil
}

// DataMultiError is an error wrapping multiple validation errors returned by
// Data.ValidateAll() if the designated constraints aren't met.
type DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DataMultiError) AllErrors() []error { return m }

// DataValidationError is the validation error returned by Data.Validate if the
// designated constraints aren't met.
type DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DataValidationError) ErrorName() string { return "DataValidationError" }

// Error satisfies the builtin error interface
func (e DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DataValidationError{}

// Validate checks the field values on Log with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Log) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Log with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LogMultiError, or nil if none found.
func (m *Log) ValidateAll() error {
	return m.validate(true)
}

func (m *Log) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FileName

	// no validation rules for MaxSize

	// no validation rules for MaxBackups

	// no validation rules for MaxAge

	if len(errors) > 0 {
		return LogMultiError(errors)
	}

	return nil
}

// LogMultiError is an error wrapping multiple validation errors returned by
// Log.ValidateAll() if the designated constraints aren't met.
type LogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogMultiError) AllErrors() []error { return m }

// LogValidationError is the validation error returned by Log.Validate if the
// designated constraints aren't met.
type LogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogValidationError) ErrorName() string { return "LogValidationError" }

// Error satisfies the builtin error interface
func (e LogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogValidationError{}

// Validate checks the field values on Data_Database with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Data_Database) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Data_Database with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Data_DatabaseMultiError, or
// nil if none found.
func (m *Data_Database) ValidateAll() error {
	return m.validate(true)
}

func (m *Data_Database) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Driver

	// no validation rules for Source

	if len(errors) > 0 {
		return Data_DatabaseMultiError(errors)
	}

	return nil
}

// Data_DatabaseMultiError is an error wrapping multiple validation errors
// returned by Data_Database.ValidateAll() if the designated constraints
// aren't met.
type Data_DatabaseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Data_DatabaseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Data_DatabaseMultiError) AllErrors() []error { return m }

// Data_DatabaseValidationError is the validation error returned by
// Data_Database.Validate if the designated constraints aren't met.
type Data_DatabaseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Data_DatabaseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Data_DatabaseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Data_DatabaseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Data_DatabaseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Data_DatabaseValidationError) ErrorName() string { return "Data_DatabaseValidationError" }

// Error satisfies the builtin error interface
func (e Data_DatabaseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sData_Database.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Data_DatabaseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Data_DatabaseValidationError{}

// Validate checks the field values on Data_Redis with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Data_Redis) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Data_Redis with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Data_RedisMultiError, or
// nil if none found.
func (m *Data_Redis) ValidateAll() error {
	return m.validate(true)
}

func (m *Data_Redis) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Network

	// no validation rules for Address

	if len(errors) > 0 {
		return Data_RedisMultiError(errors)
	}

	return nil
}

// Data_RedisMultiError is an error wrapping multiple validation errors
// returned by Data_Redis.ValidateAll() if the designated constraints aren't met.
type Data_RedisMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Data_RedisMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Data_RedisMultiError) AllErrors() []error { return m }

// Data_RedisValidationError is the validation error returned by
// Data_Redis.Validate if the designated constraints aren't met.
type Data_RedisValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Data_RedisValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Data_RedisValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Data_RedisValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Data_RedisValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Data_RedisValidationError) ErrorName() string { return "Data_RedisValidationError" }

// Error satisfies the builtin error interface
func (e Data_RedisValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sData_Redis.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Data_RedisValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Data_RedisValidationError{}

// Validate checks the field values on Data_Etcd with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Data_Etcd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Data_Etcd with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Data_EtcdMultiError, or nil
// if none found.
func (m *Data_Etcd) ValidateAll() error {
	return m.validate(true)
}

func (m *Data_Etcd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	if len(errors) > 0 {
		return Data_EtcdMultiError(errors)
	}

	return nil
}

// Data_EtcdMultiError is an error wrapping multiple validation errors returned
// by Data_Etcd.ValidateAll() if the designated constraints aren't met.
type Data_EtcdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Data_EtcdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Data_EtcdMultiError) AllErrors() []error { return m }

// Data_EtcdValidationError is the validation error returned by
// Data_Etcd.Validate if the designated constraints aren't met.
type Data_EtcdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Data_EtcdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Data_EtcdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Data_EtcdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Data_EtcdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Data_EtcdValidationError) ErrorName() string { return "Data_EtcdValidationError" }

// Error satisfies the builtin error interface
func (e Data_EtcdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sData_Etcd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Data_EtcdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Data_EtcdValidationError{}

// Validate checks the field values on Data_Rabbitmq with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Data_Rabbitmq) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Data_Rabbitmq with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Data_RabbitmqMultiError, or
// nil if none found.
func (m *Data_Rabbitmq) ValidateAll() error {
	return m.validate(true)
}

func (m *Data_Rabbitmq) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	// no validation rules for ExchangeName

	// no validation rules for QueueName

	// no validation rules for Key

	if len(errors) > 0 {
		return Data_RabbitmqMultiError(errors)
	}

	return nil
}

// Data_RabbitmqMultiError is an error wrapping multiple validation errors
// returned by Data_Rabbitmq.ValidateAll() if the designated constraints
// aren't met.
type Data_RabbitmqMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Data_RabbitmqMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Data_RabbitmqMultiError) AllErrors() []error { return m }

// Data_RabbitmqValidationError is the validation error returned by
// Data_Rabbitmq.Validate if the designated constraints aren't met.
type Data_RabbitmqValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Data_RabbitmqValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Data_RabbitmqValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Data_RabbitmqValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Data_RabbitmqValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Data_RabbitmqValidationError) ErrorName() string { return "Data_RabbitmqValidationError" }

// Error satisfies the builtin error interface
func (e Data_RabbitmqValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sData_Rabbitmq.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Data_RabbitmqValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Data_RabbitmqValidationError{}
